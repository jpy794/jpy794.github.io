<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>jpy794</title><meta charset=utf-8><meta name=description content="Ladder@第一次接触hpc比赛, 好在赛题不算太难(有很多混分空间), 因此作为新手也玩的很开心."><meta name=author content="jpy794"><link rel=canonical href=https://jpy794.github.io/zh/blog/2023-pku-hpcgame-writeup/><meta name=google-site-verification content="hkf8Kk9sh38Hm5TzNLXjKJ-Mb3LCSX4b9e4OZ56KXtw"><meta property="og:title" content="2023 Pku Hpcgame Writeup"><meta property="og:description" content="第一次接触hpc比赛, 好在赛题不算太难(有很多混分空间), 因此作为新手也玩的很开心."><meta property="og:type" content="article"><meta property="og:url" content="https://jpy794.github.io/zh/blog/2023-pku-hpcgame-writeup/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-01-25T19:19:17+08:00"><meta property="article:modified_time" content="2023-01-25T19:19:17+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="2023 Pku Hpcgame Writeup"><meta name=twitter:description content="第一次接触hpc比赛, 好在赛题不算太难(有很多混分空间), 因此作为新手也玩的很开心."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"2023 Pku Hpcgame Writeup","item":"https://jpy794.github.io/zh/blog/2023-pku-hpcgame-writeup/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2023 Pku Hpcgame Writeup","name":"2023 Pku Hpcgame Writeup","description":"第一次接触hpc比赛, 好在赛题不算太难(有很多混分空间), 因此作为新手也玩的很开心.\n","keywords":[],"articleBody":"第一次接触hpc比赛, 好在赛题不算太难(有很多混分空间), 因此作为新手也玩的很开心.\n1A 欢迎参赛 签到题, 用 SCOW 文件管理下载即可\n1B 实验室的新机器 sbatch 不如 srun 用起来方便\n#!/bin/bash srun -n1 -N1 -c1 -p compute -o output.dat ./program $1 seff \"$(cat ./job_id.dat)\" \u003e seff.dat 1C Q-1 Green500 的第一名\n1D 题目刚上线时输入输出描述很含糊, 包括\n参数在 stdin 还是 input.bin N 是否包括参数 是 mod 100001651 意义下的加法, 还是求和结果 mod 100001651 因为理解错题意 mmap() 总是挂掉, 最后不用内存映射在错误的理解下勉强过了\n2A 求积分 openmp 签到题, 可以用 reduction(+ : sum_var)\n2B 乘一乘 把矩阵乘法最外层循环用 openmp 并行化就可以满分\n2C 解方程 很奇怪, 写了一个单线程的 Gauss-Seidel 迭代也没有超时, 于是又开了 7 个线程空跑混到满分.\n原始的 Gauss-Seidel 迭代公式\n$$ x_{m}^{k+1} = \\frac {1}{a_{mm}} \\left(b_{m} - \\sum_{j=1}^{m-1} a_{mj} \\cdot x_{j}^{k+1} - \\sum_{j=m+1}^{n} a_{mj} \\cdot x_{j}^{k} \\right), \\ \\ 1 \\le m \\le n. $$\n除了边界条件, 每个方程只涉及5个未知量, 这道题的矩阵比较稀疏, 迭代公式可以改写为\n$$ u_{i,\\ j}^{k+1} = \\frac{1}{4} \\left( \\frac{f(\\frac{i}{n}, \\frac{j}{n})}{n^2} + u_{i-1,\\ j}^{k+1} +u_{i,\\ j-1}^{k+1} + u_{i+1,\\ j}^{k} +u_{i,\\ j+1}^{k} \\right), \\ \\ 1 \\le i,\\ j \\le n-1 $$\n$$ u_{ij}^{k+1} = 0, \\ \\ i,\\ j = 0, n $$\n伪代码\nu[n + 1][n + 1] all set to 0 for i in range(1, n): for j in range(1, n): y = f(i / n, j / n) / (n ** 2) u[i][j] = 0.25 * (y + u[i - 1][j] + u[i + 1][j] + u[i][j - 1] + u[i][j + 1]) 结果按题目要求的 eps 结束拿不到满分, 要减小到 1e-21 才可以, 不知道是我推的公式的问题还是不同的迭代顺序有影响\n2D 道生一 被这道题卡了好久, 数据生成部分没想到什么并行化方法, 只能优化排序算法了, 依次尝试过\n手搓并行化的归并排序 ( merge 无并行 )\n手搓并行化的快排 ( partition 无并行 )\nrust rayon 的 par_sort_unstable()\nstl 的 std::sort(std::execution::par_unseq, begin, end)\nboost 的 boost::sort::block_indirect_sort(begin, end)\n最后发现后三者性能差别不大, 似乎 boost 的略快, 但都没拿到满分\n与其优化算法, 不如蹲凌晨测评\n这道题题面后期更新过排序算法的提示, 不过我并不知道(知道也没有啥用), 可能思路出入比较大\n2E 只是把卷积的最内层循环用 simd 指令改写了一下, 就拿到了绝大部分分, 果断选择见好就收 (谨防负优化)\n2F 用题面的算法似乎是做不到满分的精度的, 这里用了 Bailey-Borwein-Plouffe 公式, 代码是从这里搬运的, 收敛速度很快, 随便跑几次精度就符合要求了\n3A 看起来很难, 交了个 handout 混了 30 分\n3B 简单改写 handout, 加上几个 cudaMalloc, cudaMemcpy 把数据拷贝到显存, 再分配给每条光线一个 thread (稍微调整下 block_size, grid_size), 计数光线时用 atomicAdd(). 这样就可以拿到基本分了\n此时用 ncu 分析性能瓶颈, 发现核心占用和 cache 命中几乎都是 100%, 猜测要做算法优化, 然而也没什么思路, 遂拿个基本分跑路\n3C 之前接触的深度学习基本为0, 炼丹过程不太顺利\nSection 1 首先老老实实的看 handout 尝试自己搭模型, 但正确率就没到过 80% (甚至一个模型不如一个), 于是开始 ctrl+c/v 编程.\n在这个仓库找到了一个 CIFAR10 的模型, 用里面 resnet20 模型练了 100 多轮就能达到 90% 以上正确率了.\n但是踩了一个坑, 搬运的模型 batch_size 是 128, 评测机似乎只接受 batch_size 64 的 result, 要修改下才能拿到 section 1 的分\nSection 2 在这里发现了一个相同数据集的模型, 用了 pytorch 预训练的 resnet50, 搬运代码后, 训练不到 5 轮准确率就能达到 90% 以上\n做题前没看到测试集存储在单独的路径下, 自己还特地从训练集里分出来的一部分当测试集, 白费了不少功夫 (pytorch 苦手只能面向 google 编程)\n4A 扫雷题我的思路是从两方面优化, 主要是参考人做扫雷的决策\n性能上, 没必要每次迭代都遍历所有格子, 只需维护一个连通区域, 每次遍历连通区域的边缘, 因为只有这里可能扩展连通区域.\n准确性上, 通过周围的 8 个格子提供的信息估计中心格子为地雷的概率.\n如果为 0 / 1, 则可以直接点击 / 标记为地雷.\n如果为 0.x, 那也可以作为依据, 在没有绝对正确的选择的情况下择优点击\n如果周围格子无法提供任何信息 (如全都未知), 那么暂时无法处理该中心格子\n该算法的单线程版本可以在 N \u003c 10000 的测试点拿到满分, 并行化也比较容易, 只需划分区域给多个线程, 每个线程在自己区域内不断扩展一个连通区域就可以, 此时划分的边界两侧要注意不能传播概率信息, 否则会有数据竞争问题 (影响正确性). 另外, 由于划分边界处概率信息的隔离, 可能会增加点到雷的数量, 不过似乎不影响拿到满分.\n4B 最后一晚时做到这题, 交了 handout 就有 90+, 心满意足了已经是\n4C 看了提示的优化小消息, 猜测就是要在发送 / 接收端增加缓冲, 合并发送 / 接收多个小消息, 不过想到之前已经混了不少分, 这题就不做了吧hh\n","wordCount":"411","inLanguage":"zh","datePublished":"2023-01-25T19:19:17+08:00","dateModified":"2023-01-25T19:19:17+08:00","author":{"@type":"Person","name":"jpy794"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jpy794.github.io/zh/blog/2023-pku-hpcgame-writeup/"},"publisher":{"@type":"Organization","name":"jpy794","logo":{"@type":"ImageObject","url":"https://jpy794.github.io/favicon.ico"}}}</script><link rel=icon type=image/png href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=/css/main.min.64bc8c4cb2304e84167c1583fa1b5de80f6d5adc95abed2e616dea0ea5680e01.css integrity="sha256-ZLyMTLIwToQWfBWD+htd6A9tWtyVq+0uYW3qDqVoDgE=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c098d85b5396dec4707ea2cead1445b4dc2ff0fc56b8dbbd9049d0d1c50ad237.js></script>
<script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/zh>HOME</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/zh/blog>文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/zh/tags>分类</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/zh/archives>历史文章</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/jpy794><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://jpy794.github.io/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>2023 Pku Hpcgame Writeup</h1></header><p><small>2023年1月25日&nbsp;· 411 字&nbsp;· 2 分钟</small>
<small></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#1a-欢迎参赛>1A 欢迎参赛</a></li><li><a href=#1b-实验室的新机器>1B 实验室的新机器</a></li><li><a href=#1c>1C</a><ul><li><a href=#q-1>Q-1</a></li></ul></li><li><a href=#1d>1D</a></li><li><a href=#2a-求积分>2A 求积分</a></li><li><a href=#2b-乘一乘>2B 乘一乘</a></li><li><a href=#2c-解方程>2C 解方程</a></li><li><a href=#2d-道生一>2D 道生一</a></li><li><a href=#2e>2E</a></li><li><a href=#2f>2F</a></li><li><a href=#3a>3A</a></li><li><a href=#3b>3B</a></li><li><a href=#3c>3C</a><ul><li><a href=#section-1>Section 1</a></li><li><a href=#section-2>Section 2</a></li></ul></li><li><a href=#4a>4A</a></li><li><a href=#4b>4B</a></li><li><a href=#4c>4C</a></li></ul></nav></div><section class=blog-content><p>第一次接触hpc比赛, 好在赛题不算太难(<del>有很多混分空间</del>), 因此作为新手也玩的很开心.</p><h2 id=1a-欢迎参赛>1A 欢迎参赛</h2><p>签到题, 用 SCOW 文件管理下载即可</p><h2 id=1b-实验室的新机器>1B 实验室的新机器</h2><p><code>sbatch</code> 不如 <code>srun</code> 用起来方便</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>srun -n1 -N1 -c1 -p compute -o output.dat ./program $1
</span></span><span style=display:flex><span>seff <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>cat ./job_id.dat<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> &gt; seff.dat
</span></span></code></pre></div><h2 id=1c>1C</h2><h3 id=q-1>Q-1</h3><p><a href=https://www.top500.org/lists/green500/2022/11/>Green500</a> 的第一名</p><h2 id=1d>1D</h2><p>题目刚上线时输入输出描述很含糊, 包括</p><ol><li>参数在 <code>stdin</code> 还是 <code>input.bin</code></li><li><code>N</code> 是否包括参数</li><li>是 <code>mod 100001651</code> 意义下的加法, 还是求和结果 <code>mod 100001651</code></li></ol><p>因为理解错题意 <code>mmap()</code> 总是挂掉, 最后不用内存映射在错误的理解下勉强过了</p><h2 id=2a-求积分>2A 求积分</h2><p>openmp 签到题, 可以用 <code>reduction(+ : sum_var)</code></p><h2 id=2b-乘一乘>2B 乘一乘</h2><p>把矩阵乘法最外层循环用 openmp 并行化就可以满分</p><h2 id=2c-解方程>2C 解方程</h2><p>很奇怪, 写了一个单线程的 Gauss-Seidel 迭代也没有超时, 于是又开了 7 个线程空跑混到满分.</p><p>原始的 Gauss-Seidel 迭代<a href=https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF-%E8%B5%9B%E5%BE%B7%E5%B0%94%E8%BF%AD%E4%BB%A3>公式</a></p><p>$$
x_{m}^{k+1} =
\frac {1}{a_{mm}} \left(b_{m} -
\sum_{j=1}^{m-1} a_{mj} \cdot x_{j}^{k+1} -
\sum_{j=m+1}^{n} a_{mj} \cdot x_{j}^{k}
\right),
\ \ 1 \le m \le n.
$$</p><p>除了边界条件, 每个方程只涉及5个未知量, 这道题的矩阵比较稀疏, 迭代公式可以改写为</p><p>$$
u_{i,\ j}^{k+1} =
\frac{1}{4} \left(
\frac{f(\frac{i}{n}, \frac{j}{n})}{n^2} +
u_{i-1,\ j}^{k+1} +u_{i,\ j-1}^{k+1} +
u_{i+1,\ j}^{k} +u_{i,\ j+1}^{k}
\right),
\ \ 1 \le i,\ j \le n-1
$$</p><p>$$
u_{ij}^{k+1} = 0,
\ \ i,\ j = 0, n
$$</p><p>伪代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>u[n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] all set to <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n):
</span></span><span style=display:flex><span>        y <span style=color:#f92672>=</span> f(i <span style=color:#f92672>/</span> n, j <span style=color:#f92672>/</span> n) <span style=color:#f92672>/</span> (n <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>        u[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.25</span> <span style=color:#f92672>*</span> (y <span style=color:#f92672>+</span> u[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>+</span> u[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][j]
</span></span><span style=display:flex><span>                            <span style=color:#f92672>+</span> u[i][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> u[i][j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span></code></pre></div><p>结果按题目要求的 eps 结束拿不到满分, 要减小到 1e-21 才可以, 不知道是我推的公式的问题还是不同的迭代顺序有影响</p><h2 id=2d-道生一>2D 道生一</h2><p>被这道题卡了好久, 数据生成部分没想到什么并行化方法, 只能优化排序算法了, 依次尝试过</p><ul><li><p>手搓并行化的归并排序 ( merge 无并行 )</p></li><li><p>手搓并行化的快排 ( partition 无并行 )</p></li><li><p>rust rayon 的 <code>par_sort_unstable()</code></p></li><li><p>stl 的 <code>std::sort(std::execution::par_unseq, begin, end)</code></p></li><li><p>boost 的 <code>boost::sort::block_indirect_sort(begin, end)</code></p></li></ul><p>最后发现后三者性能差别不大, 似乎 boost 的略快, 但都没拿到满分</p><p><del>与其优化算法, 不如蹲凌晨测评</del></p><p>这道题题面后期更新过排序算法的提示, 不过我并不知道(<del>知道也没有啥用</del>), 可能思路出入比较大</p><h2 id=2e>2E</h2><p>只是把卷积的最内层循环用 simd 指令改写了一下, 就拿到了绝大部分分, 果断选择见好就收 (谨防负优化)</p><h2 id=2f>2F</h2><p>用题面的算法似乎是做不到满分的精度的, 这里用了 Bailey-Borwein-Plouffe 公式, 代码是从<a href=https://stackoverflow.com/a/4484573>这里</a>搬运的, 收敛速度很快, 随便跑几次精度就符合要求了</p><h2 id=3a>3A</h2><p>看起来很难, 交了个 handout 混了 30 分</p><h2 id=3b>3B</h2><p>简单改写 handout, 加上几个 <code>cudaMalloc</code>, <code>cudaMemcpy</code> 把数据拷贝到显存, 再分配给每条光线一个 thread (稍微调整下 block_size, grid_size), 计数光线时用 <code>atomicAdd()</code>. 这样就可以拿到基本分了</p><p>此时用 <code>ncu</code> 分析性能瓶颈, 发现核心占用和 cache 命中几乎都是 100%, 猜测要做算法优化, 然而也没什么思路, 遂拿个基本分跑路</p><h2 id=3c>3C</h2><p>之前接触的深度学习基本为0, 炼丹过程不太顺利</p><h3 id=section-1>Section 1</h3><p>首先老老实实的看 handout 尝试自己搭模型, 但正确率就没到过 80% (甚至一个模型不如一个), 于是开始 ctrl+c/v 编程.</p><p>在<a href=https://github.com/akamaster/pytorch_resnet_cifar10/>这个仓库</a>找到了一个 CIFAR10 的模型, 用里面 resnet20 模型练了 100 多轮就能达到 90% 以上正确率了.</p><p>但是踩了一个坑, 搬运的模型 batch_size 是 128, 评测机似乎只接受 batch_size 64 的 result, 要修改下才能拿到 section 1 的分</p><h3 id=section-2>Section 2</h3><p>在<a href=https://www.kaggle.com/code/rezasaatchi/plant-seedlings-classification-pytorch/notebook>这里</a>发现了一个相同数据集的模型, 用了 pytorch 预训练的 resnet50, 搬运代码后, 训练不到 5 轮准确率就能达到 90% 以上</p><p>做题前没看到测试集存储在单独的路径下, 自己还特地从训练集里分出来的一部分当测试集, 白费了不少功夫 (pytorch 苦手只能面向 google 编程)</p><h2 id=4a>4A</h2><p>扫雷题我的思路是从两方面优化, 主要是参考人做扫雷的决策</p><ol><li><p>性能上, 没必要每次迭代都遍历所有格子, 只需维护一个连通区域, 每次遍历连通区域的边缘, 因为只有这里可能扩展连通区域.</p></li><li><p>准确性上, 通过周围的 8 个格子提供的信息估计中心格子为地雷的概率.</p><ol><li><p>如果为 0 / 1, 则可以直接点击 / 标记为地雷.</p></li><li><p>如果为 0.x, 那也可以作为依据, 在没有绝对正确的选择的情况下择优点击</p></li><li><p>如果周围格子无法提供任何信息 (如全都未知), 那么暂时无法处理该中心格子</p></li></ol></li></ol><p>该算法的单线程版本可以在 N &lt; 10000 的测试点拿到满分, 并行化也比较容易, 只需划分区域给多个线程, 每个线程在自己区域内不断扩展一个连通区域就可以, 此时划分的边界两侧要注意不能传播概率信息, 否则会有数据竞争问题 (影响正确性). 另外, 由于划分边界处概率信息的隔离, 可能会增加点到雷的数量, 不过似乎不影响拿到满分.</p><h2 id=4b>4B</h2><p>最后一晚时做到这题, 交了 handout 就有 90+, 心满意足了已经是</p><h2 id=4c>4C</h2><p>看了提示的优化小消息, 猜测就是要在发送 / 接收端增加缓冲, 合并发送 / 接收多个小消息, 不过想到之前已经混了不少分, 这题就不做了吧hh</p></section><div class=paginator><a class=prev href=https://jpy794.github.io/zh/blog/linux-suspend-on-my-laptop/><span>&larr;&nbsp;&nbsp;</span><span>让 Linux 在我的笔记本上正常休眠/睡眠</span></a></div></article></div><footer class=footer><p>&copy; 2023 <a href=https://jpy794.github.io>jpy794</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-up"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>