<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>jpy794</title><meta charset=utf-8><meta name=description content="Ladder@After a week of setting up the iPXE server, my Raspberry Pi 3B+ can now boot Linux kernel from it with TLS mutual authentication enabled. In this post I&rsquo;ll introduce how I built the SDcard image for my RPi and set up the iPXE server. Both of them are currently only for testing purposes so the process could be kind of messy. Anyway, let&rsquo;s just get it running and leave the optimization for future."><meta name=author content="jpy794"><link rel=canonical href=https://jpy794.github.io/blog/gsoc-blog-2/><meta name=google-site-verification content="hkf8Kk9sh38Hm5TzNLXjKJ-Mb3LCSX4b9e4OZ56KXtw"><meta property="og:title" content="Getting Started - GSoC '23"><meta property="og:description" content="After a week of setting up the iPXE server, my Raspberry Pi 3B+ can now boot Linux kernel from it with TLS mutual authentication enabled. In this post I&rsquo;ll introduce how I built the SDcard image for my RPi and set up the iPXE server. Both of them are currently only for testing purposes so the process could be kind of messy. Anyway, let&rsquo;s just get it running and leave the optimization for future."><meta property="og:type" content="article"><meta property="og:url" content="https://jpy794.github.io/blog/gsoc-blog-2/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-06-02T17:43:42+08:00"><meta property="article:modified_time" content="2023-06-02T17:43:42+08:00"><meta property="og:see_also" content="https://jpy794.github.io/blog/gsoc-blog-1/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Getting Started - GSoC '23"><meta name=twitter:description content="After a week of setting up the iPXE server, my Raspberry Pi 3B+ can now boot Linux kernel from it with TLS mutual authentication enabled. In this post I&rsquo;ll introduce how I built the SDcard image for my RPi and set up the iPXE server. Both of them are currently only for testing purposes so the process could be kind of messy. Anyway, let&rsquo;s just get it running and leave the optimization for future."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blogs","item":"https://jpy794.github.io/blog/"},{"@type":"ListItem","position":3,"name":"Getting Started - GSoC '23","item":"https://jpy794.github.io/blog/gsoc-blog-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Getting Started - GSoC '23","name":"Getting Started - GSoC \u002723","description":"After a week of setting up the iPXE server, my Raspberry Pi 3B+ can now boot Linux kernel from it with TLS mutual authentication enabled. In this post I\u0026rsquo;ll introduce how I built the SDcard image for my RPi and set up the iPXE server. Both of them are currently only for testing purposes so the process could be kind of messy. Anyway, let\u0026rsquo;s just get it running and leave the optimization for future.","keywords":["gsoc"],"articleBody":"After a week of setting up the iPXE server, my Raspberry Pi 3B+ can now boot Linux kernel from it with TLS mutual authentication enabled. In this post I’ll introduce how I built the SDcard image for my RPi and set up the iPXE server. Both of them are currently only for testing purposes so the process could be kind of messy. Anyway, let’s just get it running and leave the optimization for future. Also, like before I’ll append the TODO list to the end of this blog. Take a look if this post interests you. :D\nThe SDcard Image We use iPXE as the netboot firmware. To be able to boot iPXE modernly, a UEFI compatible bootloader is needed. For RPi, there’s two bootloaders as our candidates, EDK2 and U-Boot. As the former seems way too heavy for our use and the latter has better support among ARM SBCs, I chose U-Boot, hoping that could make it easier for us to port the image to SBCs other than RPi.\nHere is a demo script I wrote to build the SDcard image. Feel free to have a look if there’s any ambiguity in my description below.\nRPi3 Boot Flow When powered on, the VideoCore (VC) runs the BootROM stored in SoC, which loads bootcode.bin from SDcard to L2 cache and runs it, while the ARM core is resetted. bootcode.bin initializes SDRAM and then reads fixup.dat and start.elf from SDcard. fixup.dat is a linker file that helps spliting the SDRAM between VC and ARM. start.elf is the VC firmware, which then reads config.txt from SDcard and carries out rest of the boot process. start.elf is able to load kernel, device tree blob (DTB) and apply configurations from config.txt. We’ll configure it to load U-Boot. Finally, the reset signal for ARM core is cleared. U-Boot executes iPXE, which fetches kernel and initrd from remote server. Boom, our RPi boots! RPi firmwares fixup.dat use RPi boot process\nNow, let’s build up the SDcard image step by step.\nFirmware bootcode.bin, fixup.dat and start.elf are all firmwares provided by the vendor, which can be downloaded from RPi firmware repository. The repo also contains DTB for the RPi kernel. For RPi3B+, the file name is bcm2710-rpi-3-b-plus.dtb. If you use RPi kernel instead of mainline kernel, it’s convenient to download DTB from here directly.\nNow it time to grab a SDcard and copy the firmwares to it. RPi requires the first partition on the SDcard to be FAT16 or FAT32. That’s the where bootcode.bin, fixup.dat, start.elf shoud be placed.\nHowever, FAT32 seems to not work well with my RPi. I still don’t know why but switching to FAT16 did indeed solve my problem. I wrote it down here in case someone could have a similar issue.\nHere’s how I created the partition.\n# suppose your sdcard is /dev/sda parted --align optimal /dev/sda mklabel msdos mkpart primary fat16 0M 32M # now create the filesystem mkfs.fat -F 16 /dev/sda1 RPi partitioning explained\nThen just copy the firmwares to root directory of the partition we’ve just created.\nConfig.txt Apart from those blobs, we also need to provide a config.txt. In following example, some of the parameters are necessary for boot process, some are set for the convenience of debug.\n# we want to start u-boot in 64-bit mode arm_64bit=1 # this is the device tree blob start.elf should load device_tree=bcm2710-rpi-3-b-plus.dtb # we'll build u-boot and place the binay here later kernel=u-boot.bin # miniuart is disabled by default, enable it enable_uart=1 # set frequency of VC core to a fixed value so that miniuart has a stable baud rate core_freq=250 # enable logging for bootcode.bin and start.elf uart_2ndstage=1 Among configurations above, the trickiest part is to get the UART working. RPi3B+ has 2 UART, PL011 and mini UART. By default, the former is used by bluetooth and the latter is mapped to GPIO. However, the clock of mini UART is linked to clock of VC core. If frequency of VC core is not fixed, we’ll never get valid output from mini UART due to the changing baud rate.\ndocumentation of config.txt\nNow, simply plug the SDcard into the RPi, connect the serial, power it up and you should see some logs printed out like\nRaspberry Pi Bootcode Read File: config.txt, 209 Read File: start.elf, 2975744 (bytes) Read File: fixup.dat, 7266 (bytes) MESS:00:00:01.212454:0: brfs: File read: /mfs/sd/config.txt MESS:00:00:01.216673:0: brfs: File read: 209 bytes ... U-Boot There’s RPi support in mainline U-Boot. So it’s pretty straightforward to boot it on our board.\nFirst, let’s build for RPi3B+ target.\ngit clone https://github.com/u-boot/u-boot.git cd u-boot make ARCH=arm CROSS_COMPILE=aarch64-linux-gnu- rpi_3_b_plus_defconfig # this should generate u-boot.bin make ARCH=arm CROSS_COMPILE=aarch64-linux-gnu- -j`nproc` Then, we need to create a boot script (boot.cmd) which executes the iPXE binay (efi/tools/snp.efi).\nboot.cmd\nload mmc 0:1 $kernel_addr_r efi/tools/snp.efi bootefi $kernel_addr_r # this should generate boot.scr ./tools/mkimage -A arm -T script -d boot.cmd boot.scr Copy u-boot.bin and boot.scr to root directory of the boot partition and power the RPi up. There should be U-Boot logs printed out.\nU-Boot 2023.04-rc4-00053-g8be7b4629e (Jun 03 2023 - 22:19:18 +0800) DRAM: 948 MiB RPI 3 Model B+ (0xa020d3) Core: 66 devices, 14 uclasses, devicetree: embed MMC: mmc@7e202000: 0, mmc@7e300000: 1 Loading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1... In: serial Out: vidconsole Err: vidconsole Net: No ethernet found. starting USB... Bus usb@7e980000: USB DWC2 scanning bus usb@7e980000 for devices... 4 USB Device(s) found scanning usb for storage devices... 0 Storage Device(s) found Hit any key to stop autoboot: 0 iPXE Before building iPXE, enable a few features we’ll need later firstly.\ngit clone https://github.com/ipxe/ipxe.git cd ipxe/src config/local/general.h\n/* general.h */ #define NSLOOKUP_CMD /* Name resolution command */ #define PING_CMD /* Ping command */ #define NTP_CMD /* NTP commands */ #define VLAN_CMD /* VLAN commands */ #define IMAGE_EFI /* EFI image support */ #define DOWNLOAD_PROTO_HTTPS /* Secure Hypertext Transfer Protocol */ #define DOWNLOAD_PROTO_FTP /* File Transfer Protocol */ #define DOWNLOAD_PROTO_NFS /* Network File System Protocol */ #define DOWNLOAD_PROTO_FILE /* Local file system access */ Like U-Boot, we need to create a boot script (embed.ipxe).\nembed.ipxe\n#!ipxe :retry dhcp || goto retry ntp pool.ntp.org || goto retry # we'll replace the url with our ipxe server later chain -a https://example.com || goto retry # unreachable goto retry According to iPXE documentation, we should select snp target for ARM devices. I didn’t notice that and tried several times before finding the right one. :P\n# this should generate bin-arm64-efi/snp.efi make CROSS_COMPILE=aarch64-linux-gnu- EMBED=embed.ipxe bin-arm64-efi/snp.efi -j`nproc` Next, copy snp.efi to /efi/tools/snp.efi and we should get a working iPXE.\niPXE 1.21.1+ (gb00935) -- Open Source Network Boot Firmware -- https://ipxe.org Features: DNS FTP HTTP HTTPS iSCSI NFS TFTP VLAN AoE EFI Menu lan78xx_eth Waiting for PHY auto negotiation to complete....... done Configuring (net0 b8:27:eb:ab:cb:dc)....... ok The iPXE Server In Valve Infra, a gateway fetches its kernel and initrd through public network. To protect our netboot from man-in-the-middle attack and unauthorized access, we need a HTTPS iPXE server with client certificate enabled. Basically, we need to get the following things done.\nGet a SSL certificate for the domain. Set up a HTTPS server with Nginx. Create a CA and enable client verification in Nginx. Issue client certificates using the CA we’ve just generated. Embed the ceritficate in our iPXE binary. Here are some references.\nmupuf’s blog valve infra - ipxe boot server ipxe - crypto nginx - http_ssl_module\nHTTPS Server Thanks to ACME protocol and service providers like Let’s Encrypt, ZeroSSL, etc, we can get a SSL ceritificate in a few minutes. I used acme.sh to automate the process.\nRemember to get a RSA certificate as iPXE does not support ECC certificate currently.\nThere used to be size limit for the server certificate because iPXE didn’t support fragmented TLS handshake. But now the issue has already been fixed. So feel free to get a SSL certificate of any length. :D\nNow simply install and configure Nginx. Create a new configuration at /etc/nginx/sites-available and link it to /etc/nginx/sites-enabled. Add a server block with a normal SSL configuration. Set ssl_certificate to the SSL certificate and ssl_certificate_key to your private key. This should give you a working HTTPS server.\niPXE doesn’t support all cipher suites though. So take a look at their documentation and check your Nginx settings twice. I also found Mozilla SSL configuration generator useful. It generates Nginx configuration that works out of the box with iPXE when set to Intermediate mode.\nYou can use nmap to detect cipher suites your server allows.\nnmap -script ssl-enum-ciphers -p 443 example.com If all above are set correctly, you can replace the url in the iPXE boot script with your server address and host a simple iPXE script with Nginx, like\n#!ipxe echo hello from server The RPi should be able to output hello from server.\nClient Certificate About how to create CA and issue client certificates, explanation from Valve Infra and iPXE are clear enough. It’s basically some OpenSSL thing. Let’s simply skip it.\nI suppose you’ve already got a CA, a client certificate and corresponding private key.\nServer For server side, adding two lines to the server block of the Nginx configuration created above is enough.\nssl_client_certificate /path/to/ca ssl_verify_client on; Now, the resources of the server shouldn’t be accessible from client without certificates, like your browser.\nClient For client side, we need to rebuild iPXE to embed the client certificate and private key.\nmake bin-arm64-efi/snp.efi -j`nproc` \\ CROSS_COMPILE=aarch64-linux-gnu- \\ EMBED=embed.ipxe \\ PRIVKEY=client.key CERT=client.crt Be sure to keep the generated snp.efi in a safe place. It contains unencryped private key of your client certificate.\nNow, only your RPi could download scripts/binaries from your iPXE server!\nAn iPXE Issue When tring to embed the private key in the iPXE binary, I encountered a weird issue. When doing a SSL handshake, iPXE complained that no private key was found corresponding to the client certificate, which I had definitely passed to make by PRIVKEY=....\nI enabled more debug output and found iPXE failed parsing the private key in rsa_parse_mod_exp(). The private key is stored in ASN.1 structure. So I used openssl asn1parse to decode my private key. The output didn’t match the structure expected by the parsing function at all. At that point I realized something could be wrong with my private key.\nIt didn’t take me long to find that the private key I generated was in PKCS#8 format and the parsing function assumed it’s PKCS#1. I went to check OpenSSL documentation. Guess what? OpenSSL 3.0 and above outputs private key in PKCS#8 by default instead of PKCS#1, which explained exactly the problem I was having.\nAdding a -traditional parameter should make OpenSSL output private key in the right format. After converting format of my private key to PKCS#1, I tried again. But it still didn’t work.\nAt last, I found iPXE also called OpenSSL in its Makefile to convert the private key to DER binary format, which, of course, converted my PKCS#1 input back to PKCS#8 again!\nSo the solution is simple. When OpenSSL version \u003e= 3, append a -traditional to that command in Makefile. I made a small patch and created a PR. The maintainer of iPXE responded pretty fast and chose to add PKCS#8 formatted private key support instead. That’s way more better than my workaround!\nWhat’s Next After learning all those above and setting up the test environment, now it’s time to do some real work.\nI’ll create a repository that generates SDcard image with UEFI bootloader for RPi (hope there’ll be more SBCs supported in the future). That image will serve as a base image so that we could ship different iPXE with it for different use, like a HTTP-only version for test machines and a HTTPS with client verification version for gateways. Actually, generating SDcard image for gateways from base image is also on my TODO list, which involves some changes in ipxe-boot-server.\nThere’s also a lot of questions left, such as\nThe way we load device tree Currently by RPi firmware or U-Boot. Should we load it by iPXE so that we could switch kernel and device tree together remotely? The specification of the base image for both MBR and GPT So that we could put the iPXE binary in the right place when building the SDcard image. Hope in my next blog there’ll be answers to all of them. :D\nThat’s all. Thank you for reading until the end! Hope to see you again soon.\n","wordCount":"2064","inLanguage":"en","datePublished":"2023-06-02T17:43:42+08:00","dateModified":"2023-06-02T17:43:42+08:00","author":{"@type":"Person","name":"jpy794"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jpy794.github.io/blog/gsoc-blog-2/"},"publisher":{"@type":"Organization","name":"jpy794","logo":{"@type":"ImageObject","url":"https://jpy794.github.io/favicon.ico"}}}</script><link rel=icon type=image/png href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=/css/main.min.64bc8c4cb2304e84167c1583fa1b5de80f6d5adc95abed2e616dea0ea5680e01.css integrity="sha256-ZLyMTLIwToQWfBWD+htd6A9tWtyVq+0uYW3qDqVoDgE=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.872dfd2cd00064018a833a6e8e77a0fbf8fbac159546f2f205d4dad79a5d8e15.js></script>
<script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archives</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/jpy794><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://jpy794.github.io/zh/>中</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Getting Started - GSoC '23</h1></header><p><small>June 2, 2023&nbsp;· 2064 words&nbsp;· 10 min</small>
<small>·
<a href=https://jpy794.github.io/tags/gsoc/>gsoc</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#the-sdcard-image>The SDcard Image</a><ul><li><a href=#rpi3-boot-flow>RPi3 Boot Flow</a></li><li><a href=#firmware>Firmware</a></li><li><a href=#configtxt>Config.txt</a></li><li><a href=#u-boot>U-Boot</a></li><li><a href=#ipxe>iPXE</a></li></ul></li><li><a href=#the-ipxe-server>The iPXE Server</a><ul><li><a href=#https-server>HTTPS Server</a></li><li><a href=#client-certificate>Client Certificate</a></li></ul></li><li><a href=#whats-next>What&rsquo;s Next</a></li></ul></nav></div><section class=blog-content><p>After a week of setting up the iPXE server, my Raspberry Pi 3B+ can now boot Linux kernel from it with TLS mutual authentication enabled. In this post I&rsquo;ll introduce how I built the SDcard image for my RPi and set up the iPXE server. Both of them are currently only for testing purposes so the process could be kind of messy. Anyway, let&rsquo;s just get it running and leave the optimization for future. Also, like before I&rsquo;ll append the TODO list to the end of this blog. Take a look if this post interests you. :D</p><h2 id=the-sdcard-image>The SDcard Image</h2><p>We use <a href=https://ipxe.org>iPXE</a> as the netboot firmware. To be able to boot iPXE modernly, a UEFI compatible bootloader is needed. For RPi, there&rsquo;s two bootloaders as our candidates, <a href=https://github.com/tianocore/edk2-platforms/tree/master/Platform/RaspberryPi/RPi3>EDK2</a> and <a href=https://u-boot.readthedocs.io/en/latest/develop/uefi/uefi.html>U-Boot</a>. As the former seems way too heavy for our use and the latter has better support among ARM SBCs, I chose U-Boot, hoping that could make it easier for us to port the image to SBCs other than RPi.</p><p><a href=https://github.com/jpy794/rpi-uboot-ipxe>Here</a> is a demo script I wrote to build the SDcard image. Feel free to have a look if there&rsquo;s any ambiguity in my description below.</p><h3 id=rpi3-boot-flow>RPi3 Boot Flow</h3><ul><li>When powered on, the VideoCore (VC) runs the BootROM stored in SoC, which loads <code>bootcode.bin</code> from SDcard to L2 cache and runs it, while the ARM core is resetted.</li><li><code>bootcode.bin</code> initializes SDRAM and then reads <code>fixup.dat</code> and <code>start.elf</code> from SDcard.<ul><li><code>fixup.dat</code> is a linker file that helps spliting the SDRAM between VC and ARM.</li><li><code>start.elf</code> is the VC firmware, which then reads <code>config.txt</code> from SDcard and carries out rest of the boot process.</li></ul></li><li><code>start.elf</code> is able to load kernel, device tree blob (DTB) and apply configurations from <code>config.txt</code>. We&rsquo;ll configure it to load U-Boot.</li><li>Finally, the reset signal for ARM core is cleared. U-Boot executes iPXE, which fetches kernel and initrd from remote server. Boom, our RPi boots!</li></ul><blockquote><p><a href=https://www.raspberrypi.com/documentation/computers/configuration.html#boot-folder-contents>RPi firmwares</a><br><a href="https://forums.raspberrypi.com/viewtopic.php?t=173308">fixup.dat use</a><br><a href="https://forums.raspberrypi.com//viewtopic.php?f=63&amp;t=6685">RPi boot process</a></p></blockquote><p>Now, let&rsquo;s build up the SDcard image step by step.</p><h3 id=firmware>Firmware</h3><p><code>bootcode.bin</code>, <code>fixup.dat</code> and <code>start.elf</code> are all firmwares provided by the vendor, which can be downloaded from <a href=https://github.com/raspberrypi/firmware/tree/master/boot>RPi firmware repository</a>. The repo also contains DTB for the <a href=https://github.com/raspberrypi/firmware/tree/master/boot>RPi kernel</a>. For RPi3B+, the file name is <code>bcm2710-rpi-3-b-plus.dtb</code>. If you use RPi kernel instead of mainline kernel, it&rsquo;s convenient to download DTB from here directly.</p><p>Now it time to grab a SDcard and copy the firmwares to it. RPi requires the first partition on the SDcard to be FAT16 or FAT32. That&rsquo;s the where <code>bootcode.bin</code>, <code>fixup.dat</code>, <code>start.elf</code> shoud be placed.</p><p>However, FAT32 seems to not work well with my RPi. I still don&rsquo;t know why but switching to FAT16 did indeed solve my problem. I wrote it down here in case someone could have a similar issue.</p><p>Here&rsquo;s how I created the partition.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># suppose your sdcard is /dev/sda</span>
</span></span><span style=display:flex><span>parted --align optimal /dev/sda mklabel msdos mkpart primary fat16 0M 32M
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># now create the filesystem</span>
</span></span><span style=display:flex><span>mkfs.fat -F <span style=color:#ae81ff>16</span> /dev/sda1
</span></span></code></pre></div><blockquote><p><a href=https://github.com/raspberrypi/noobs/wiki/Standalone-partitioning-explained>RPi partitioning explained</a></p></blockquote><p>Then just copy the firmwares to root directory of the partition we&rsquo;ve just created.</p><h3 id=configtxt>Config.txt</h3><p>Apart from those blobs, we also need to provide a <code>config.txt</code>. In following example, some of the parameters are necessary for boot process, some are set for the convenience of debug.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># we want to start u-boot in 64-bit mode</span>
</span></span><span style=display:flex><span>arm_64bit<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># this is the device tree blob start.elf should load</span>
</span></span><span style=display:flex><span>device_tree<span style=color:#f92672>=</span>bcm2710-rpi-3-b-plus.dtb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># we&#39;ll build u-boot and place the binay here later</span>
</span></span><span style=display:flex><span>kernel<span style=color:#f92672>=</span>u-boot.bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># miniuart is disabled by default, enable it</span>
</span></span><span style=display:flex><span>enable_uart<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># set frequency of VC core to a fixed value so that miniuart has a stable baud rate</span>
</span></span><span style=display:flex><span>core_freq<span style=color:#f92672>=</span><span style=color:#ae81ff>250</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># enable logging for bootcode.bin and start.elf</span>
</span></span><span style=display:flex><span>uart_2ndstage<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Among configurations above, the trickiest part is to get the UART working. RPi3B+ has 2 UART, PL011 and mini UART. By default, the former is used by bluetooth and the latter is mapped to GPIO. However, the clock of mini UART is linked to clock of VC core. If frequency of VC core is not fixed, we&rsquo;ll never get valid output from mini UART due to the changing baud rate.</p><blockquote><p><a href=https://www.raspberrypi.com/documentation/computers/config_txt.html>documentation of <code>config.txt</code></a></p></blockquote><p>Now, simply plug the SDcard into the RPi, connect the serial, power it up and you should see some logs printed out like</p><pre tabindex=0><code>Raspberry Pi Bootcode
Read File: config.txt, 209
Read File: start.elf, 2975744 (bytes)
Read File: fixup.dat, 7266 (bytes)
MESS:00:00:01.212454:0: brfs: File read: /mfs/sd/config.txt
MESS:00:00:01.216673:0: brfs: File read: 209 bytes
...
</code></pre><h3 id=u-boot>U-Boot</h3><p>There&rsquo;s RPi support in mainline U-Boot. So it&rsquo;s pretty straightforward to boot it on our board.</p><p>First, let&rsquo;s build for RPi3B+ target.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git clone https://github.com/u-boot/u-boot.git
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cd u-boot
</span></span><span style=display:flex><span>make ARCH<span style=color:#f92672>=</span>arm CROSS_COMPILE<span style=color:#f92672>=</span>aarch64-linux-gnu- rpi_3_b_plus_defconfig
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># this should generate u-boot.bin</span>
</span></span><span style=display:flex><span>make ARCH<span style=color:#f92672>=</span>arm CROSS_COMPILE<span style=color:#f92672>=</span>aarch64-linux-gnu- -j<span style=color:#e6db74>`</span>nproc<span style=color:#e6db74>`</span>
</span></span></code></pre></div><p>Then, we need to create a boot script (<code>boot.cmd</code>) which executes the iPXE binay (<code>efi/tools/snp.efi</code>).</p><p><code>boot.cmd</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>load mmc 0:1 $kernel_addr_r efi/tools/snp.efi
</span></span><span style=display:flex><span>bootefi $kernel_addr_r
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># this should generate boot.scr</span>
</span></span><span style=display:flex><span>./tools/mkimage -A arm -T script -d boot.cmd boot.scr
</span></span></code></pre></div><p>Copy <code>u-boot.bin</code> and <code>boot.scr</code> to root directory of the boot partition and power the RPi up. There should be U-Boot logs printed out.</p><pre tabindex=0><code>U-Boot 2023.04-rc4-00053-g8be7b4629e (Jun 03 2023 - 22:19:18 +0800)

DRAM:  948 MiB
RPI 3 Model B+ (0xa020d3)
Core:  66 devices, 14 uclasses, devicetree: embed
MMC:   mmc@7e202000: 0, mmc@7e300000: 1
Loading Environment from FAT... Unable to read &#34;uboot.env&#34; from mmc0:1...
In:    serial
Out:   vidconsole
Err:   vidconsole
Net:   No ethernet found.
starting USB...
Bus usb@7e980000: USB DWC2
scanning bus usb@7e980000 for devices... 4 USB Device(s) found
       scanning usb for storage devices... 0 Storage Device(s) found
Hit any key to stop autoboot:  0
</code></pre><h3 id=ipxe>iPXE</h3><p>Before building iPXE, enable a few features we&rsquo;ll need later firstly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git clone https://github.com/ipxe/ipxe.git
</span></span><span style=display:flex><span>cd ipxe/src
</span></span></code></pre></div><p><code>config/local/general.h</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* general.h */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NSLOOKUP_CMD            </span><span style=color:#75715e>/* Name resolution command */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PING_CMD                </span><span style=color:#75715e>/* Ping command */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NTP_CMD                 </span><span style=color:#75715e>/* NTP commands */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define VLAN_CMD                </span><span style=color:#75715e>/* VLAN commands */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define IMAGE_EFI               </span><span style=color:#75715e>/* EFI image support */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define DOWNLOAD_PROTO_HTTPS    </span><span style=color:#75715e>/* Secure Hypertext Transfer Protocol */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define DOWNLOAD_PROTO_FTP      </span><span style=color:#75715e>/* File Transfer Protocol */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define DOWNLOAD_PROTO_NFS      </span><span style=color:#75715e>/* Network File System Protocol */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define DOWNLOAD_PROTO_FILE     </span><span style=color:#75715e>/* Local file system access */</span><span style=color:#75715e>
</span></span></span></code></pre></div><p>Like U-Boot, we need to create a boot script (<code>embed.ipxe</code>).</p><p><code>embed.ipxe</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#!ipxe
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>:retry
</span></span><span style=display:flex><span>dhcp <span style=color:#f92672>||</span> goto retry
</span></span><span style=display:flex><span>ntp pool.ntp.org <span style=color:#f92672>||</span> goto retry
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># we&#39;ll replace the url with our ipxe server later</span>
</span></span><span style=display:flex><span>chain -a https://example.com <span style=color:#f92672>||</span> goto retry
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># unreachable</span>
</span></span><span style=display:flex><span>goto retry
</span></span></code></pre></div><p>According to <a href=https://ipxe.org/appnote/buildtargets>iPXE documentation</a>, we should select <code>snp</code> target for ARM devices. I didn&rsquo;t notice that and tried several times before finding the right one. :P</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># this should generate bin-arm64-efi/snp.efi</span>
</span></span><span style=display:flex><span>make CROSS_COMPILE<span style=color:#f92672>=</span>aarch64-linux-gnu- EMBED<span style=color:#f92672>=</span>embed.ipxe bin-arm64-efi/snp.efi -j<span style=color:#e6db74>`</span>nproc<span style=color:#e6db74>`</span>
</span></span></code></pre></div><p>Next, copy <code>snp.efi</code> to <code>/efi/tools/snp.efi</code> and we should get a working iPXE.</p><pre tabindex=0><code>iPXE 1.21.1+ (gb00935) -- Open Source Network Boot Firmware -- https://ipxe.org
Features: DNS FTP HTTP HTTPS iSCSI NFS TFTP VLAN AoE EFI Menu
lan78xx_eth Waiting for PHY auto negotiation to complete....... done
Configuring (net0 b8:27:eb:ab:cb:dc)....... ok
</code></pre><h2 id=the-ipxe-server>The iPXE Server</h2><p>In Valve Infra, a gateway fetches its kernel and initrd through public network. To protect our netboot from man-in-the-middle attack and unauthorized access, we need a HTTPS iPXE server with client certificate enabled. Basically, we need to get the following things done.</p><ul><li>Get a SSL certificate for the domain.</li><li>Set up a HTTPS server with Nginx.</li><li>Create a CA and enable client verification in Nginx.</li><li>Issue client certificates using the CA we&rsquo;ve just generated. Embed the ceritficate in our iPXE binary.</li></ul><p>Here are some references.</p><blockquote><p><a href=https://mupuf.org/blog/2022/01/10/setting-up-a-ci-system-part-3-provisioning-your-ci-gateway/>mupuf&rsquo;s blog</a><br><a href=https://gitlab.freedesktop.org/mupuf/valve-infra/-/blob/master/ipxe-boot-server/README.md>valve infra - ipxe boot server</a><br><a href=https://ipxe.org/crypto>ipxe - crypto</a><br><a href=http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_trusted_certificate>nginx - http_ssl_module</a></p></blockquote><h3 id=https-server>HTTPS Server</h3><p>Thanks to <a href=https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment>ACME</a> protocol and service providers like Let&rsquo;s Encrypt, ZeroSSL, etc, we can get a SSL ceritificate in a few minutes. I used <a href=https://github.com/acmesh-official/acme.sh>acme.sh</a> to automate the process.</p><p>Remember to get a RSA certificate as iPXE does not support ECC certificate currently.</p><p>There used to be size limit for the server certificate because iPXE didn&rsquo;t support fragmented TLS handshake. But now the issue has already been <a href=https://github.com/ipxe/ipxe/pull/930>fixed</a>. So feel free to get a SSL certificate of any length. :D</p><p>Now simply install and configure Nginx. Create a new configuration at <code>/etc/nginx/sites-available</code> and link it to <code>/etc/nginx/sites-enabled</code>. Add a server block with a normal SSL configuration. Set <code>ssl_certificate</code> to the SSL certificate and <code>ssl_certificate_key</code> to your private key. This should give you a working HTTPS server.</p><p>iPXE doesn&rsquo;t support all cipher suites though. So take a look at their <a href=https://ipxe.org/crypto>documentation</a> and check your Nginx settings twice. I also found <a href="https://ssl-config.mozilla.org/#server=nginx&amp;config=intermediate">Mozilla SSL configuration generator</a> useful. It generates Nginx configuration that works out of the box with iPXE when set to <code>Intermediate</code> mode.</p><p>You can use <code>nmap</code> to detect cipher suites your server allows.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>nmap -script ssl-enum-ciphers -p <span style=color:#ae81ff>443</span> example.com
</span></span></code></pre></div><p>If all above are set correctly, you can replace the url in the iPXE boot script with your server address and host a simple iPXE script with Nginx, like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#!ipxe
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>echo hello from server
</span></span></code></pre></div><p>The RPi should be able to output <code>hello from server</code>.</p><h3 id=client-certificate>Client Certificate</h3><p>About how to create CA and issue client certificates, explanation from <a href=https://gitlab.freedesktop.org/mupuf/valve-infra/-/blob/master/ipxe-boot-server/README.md>Valve Infra</a> and <a href=https://ipxe.org/crypto>iPXE</a> are clear enough. It&rsquo;s basically some OpenSSL thing. Let&rsquo;s simply skip it.</p><p>I suppose you&rsquo;ve already got a CA, a client certificate and corresponding private key.</p><h4 id=server>Server</h4><p>For server side, adding two lines to the server block of the Nginx configuration created above is enough.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ssl_client_certificate /path/to/ca
</span></span><span style=display:flex><span>ssl_verify_client on;
</span></span></code></pre></div><p>Now, the resources of the server shouldn&rsquo;t be accessible from client without certificates, like your browser.</p><h4 id=client>Client</h4><p>For client side, we need to rebuild iPXE to embed the client certificate and private key.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make bin-arm64-efi/snp.efi -j<span style=color:#e6db74>`</span>nproc<span style=color:#e6db74>`</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    CROSS_COMPILE<span style=color:#f92672>=</span>aarch64-linux-gnu- <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    EMBED<span style=color:#f92672>=</span>embed.ipxe <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    PRIVKEY<span style=color:#f92672>=</span>client.key CERT<span style=color:#f92672>=</span>client.crt
</span></span></code></pre></div><p>Be sure to keep the generated <code>snp.efi</code> in a safe place. It contains unencryped private key of your client certificate.</p><p>Now, only your RPi could download scripts/binaries from your iPXE server!</p><h4 id=an-ipxe-issue>An iPXE Issue</h4><p>When tring to embed the private key in the iPXE binary, I encountered a weird issue. When doing a SSL handshake, iPXE complained that no private key was found corresponding to the client certificate, which I had definitely passed to <code>make</code> by <code>PRIVKEY=...</code>.</p><p>I enabled more debug output and found iPXE failed parsing the private key in <a href=https://github.com/ipxe/ipxe/blob/6a7f560e60837fc2ce82a7aa976035656f7d231e/src/crypto/rsa.c#L159><code>rsa_parse_mod_exp()</code></a>. The private key is stored in ASN.1 structure. So I used <code>openssl asn1parse</code> to decode my private key. The output didn&rsquo;t match the structure expected by the parsing function at all. At that point I realized something could be wrong with my private key.</p><p>It didn&rsquo;t take me long to find that the private key I generated was in PKCS#8 format and the parsing function assumed it&rsquo;s PKCS#1. I went to check OpenSSL documentation. Guess what? OpenSSL 3.0 and above outputs private key in PKCS#8 by default instead of PKCS#1, which explained exactly the problem I was having.</p><p>Adding a <code>-traditional</code> parameter should make OpenSSL output private key in the right format. After converting format of my private key to PKCS#1, I tried again. But it still didn&rsquo;t work.</p><p>At last, I found iPXE also called OpenSSL in its <a href=https://github.com/ipxe/ipxe/blob/6a7f560e60837fc2ce82a7aa976035656f7d231e/src/Makefile.housekeeping#L691>Makefile</a> to convert the private key to DER binary format, which, of course, converted my PKCS#1 input back to PKCS#8 again!</p><p>So the solution is simple. When OpenSSL version >= 3, append a <code>-traditional</code> to that command in Makefile. I made a small patch and created a <a href=https://github.com/ipxe/ipxe/pull/963>PR</a>. The maintainer of iPXE responded pretty fast and chose to add PKCS#8 formatted private key <a href=https://github.com/ipxe/ipxe/pull/964>support</a> instead. That&rsquo;s way more better than my workaround!</p><h2 id=whats-next>What&rsquo;s Next</h2><p>After learning all those above and setting up the test environment, now it&rsquo;s time to do some real work.</p><p>I&rsquo;ll create a repository that generates SDcard image with UEFI bootloader for RPi (hope there&rsquo;ll be more SBCs supported in the future). That image will serve as a base image so that we could ship different iPXE with it for different use, like a HTTP-only version for test machines and a HTTPS with client verification version for gateways. Actually, generating SDcard image for gateways from base image is also on my TODO list, which involves some changes in <a href=https://gitlab.freedesktop.org/mupuf/valve-infra/-/tree/master/ipxe-boot-server>ipxe-boot-server</a>.</p><p>There&rsquo;s also a lot of questions left, such as</p><ul><li>The way we load device tree<ul><li>Currently by RPi firmware or U-Boot.</li><li>Should we load it by iPXE so that we could switch kernel and device tree together remotely?</li></ul></li><li>The specification of the base image for both MBR and GPT<ul><li>So that we could put the iPXE binary in the right place when building the SDcard image.</li></ul></li></ul><p>Hope in my next blog there&rsquo;ll be answers to all of them. :D</p><p>That&rsquo;s all. Thank you for reading until the end! Hope to see you again soon.</p></section><div class=paginator><a class=next href=https://jpy794.github.io/blog/gsoc-blog-1/><span>The Project - GSoC '23</span><span>&nbsp;&nbsp;&rarr;</span></a></div><div class=related-resources><h3>Related Resources</h3><nav><ul><li><a href=/blog/gsoc-blog-1/>The Project - GSoC '23</a></li></ul></nav></div></article></div><footer class=footer><p>&copy; 2023 <a href=https://jpy794.github.io>jpy794</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-up"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>